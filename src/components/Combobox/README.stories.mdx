import { Meta, Story, Canvas, ArgsTable, Source, Preview } from '@storybook/addon-docs';
import dedent from 'ts-dedent';

import { Combobox, Listbox, ListboxOption, ComboboxTextField, Icon, TextContainer, Tag } from '@/polaris-vue';
import SearchMinor from '@icons/SearchMinor.svg';

<Meta
  title="Components / Forms / Combobox"
  component={ Combobox }
  argTypes={{
    default: {
      table: {
        disable: 'true',
      },
    },
  }}
/>

# Combobox

The Combobox component implements part of the [Aria 1.2 combobox](https://www.w3.org/TR/wai-aria-practices-1.2/#combobox) specs on a TextField and a popover containing a Listbox.
Like Autocomplete, Combobox allows merchants to quickly search through and select from large collections of options.

<br/><br/>

### Basic autocomplete

Use to help merchants complete text input quickly from a list of options.

export const BasicAutocomplete = (args, { argTypes }) => ({
  components: { Combobox, Listbox, ListboxOption, ComboboxTextField, Icon },
  template: `
  <Combobox>
    <template slot="activator">
      <ComboboxTextField  :labelHidden="true" v-model="searchValue" placeholder="Search customer">
        <template slot="prefix">
          <Icon :source="searchIcon" color="inkLighter"></Icon>
        </template>
      </ComboboxTextField>
    </template>
    <Listbox @select="handleOptionSelected">
      <ListboxOption
        v-for="option, index in filteredOptions"
        :key="index"
        :value="option.value"
        :selected="isOptionSelected(option, index)"
      >
        {{ option.label }}
      </ListboxOption>
    </Listbox>
  </Combobox>`,
  data() {
    return {
      searchIcon: SearchMinor,
      options: [
        {value: 'rustic', label: 'Rustic'},
        {value: 'antique', label: 'Antique'},
        {value: 'vinyl', label: 'Vinyl'},
        {value: 'vintage', label: 'Vintage'},
        {value: 'refurbished', label: 'Refurbished'},
      ],
      searchValue: '',
    };
  },
  computed: {
    filteredOptions() {
      return this.searchValue
        ? this.options
          .filter(el => el.value.includes(this.searchValue))
        : this.options;
    }
  },
  methods: {
    handleOptionSelected(option) {
      this.searchValue = option;
    },
    isOptionSelected(option, index) {
      if (this.searchValue) return this.searchValue === option.value;
      return index === 0;
    }
  },
});
BasicAutocomplete.parameters = {
  docs: {
    source: false,
  },
};

<Canvas>
  <Story story={BasicAutocomplete} name="Basic Autocomplete" height="200px" inline={false}></Story>
</Canvas>

### Multiple tags autocomplete

Use to help merchants select multiple options from a list curated by the text input.

export const MultiTagAutocomplete = (args, { argTypes }) => ({
  components: { Combobox, Listbox, ListboxOption, ComboboxTextField, Icon, TextContainer, Tag },
  template: `
  <div>
    <Combobox :allowMultiple="true">
      <template slot="activator">
        <ComboboxTextField  :labelHidden="true" v-model="searchValue" placeholder="Search customer">
          <template slot="prefix">
            <Icon :source="searchIcon" color="inkLighter"></Icon>
          </template>
        </ComboboxTextField>
      </template>
      <Listbox @select="handleOptionSelected">
        <ListboxOption
          v-for="option, index in filteredOptions"
          :key="index"
          :value="option.value"
          :selected="selectedOptions.includes(option.value)"
        >
          {{ option.label }}
        </ListboxOption>
      </Listbox>
    </Combobox>
    <TextContainer>
      <Tag
        v-for="option, index in selectedOptions"
        :key="index"
        @remove="handleRemoveTag(option)"
      >
        {{ option }}
      </Tag>
    </TextContainer>
  </div>
  `,
  data() {
    return {
      searchIcon: SearchMinor,
      options: [
        {value: 'rustic', label: 'Rustic'},
        {value: 'antique', label: 'Antique'},
        {value: 'vinyl', label: 'Vinyl'},
        {value: 'vintage', label: 'Vintage'},
        {value: 'refurbished', label: 'Refurbished'},
      ],
      searchValue: '',
      selectedOptions: [],
    };
  },
  computed: {
    filteredOptions() {
      return this.searchValue
        ? this.options
          .filter(el => el.value.includes(this.searchValue))
        : this.options;
    }
  },
  methods: {
    handleOptionSelected(option) {
      if (this.selectedOptions.includes(option)) {
        this.selectedOptions = this.selectedOptions.filter(el => el !== option);
      }
      else {
        this.selectedOptions.push(option);
      }
    },
    handleRemoveTag(optionVal) {
      this.selectedOptions = this.selectedOptions.filter(el => el !== optionVal);
    }
  },
});
MultiTagAutocomplete.parameters = {
  docs: {
    source: false,
  },
};

<Canvas>
  <Story story={MultiTagAutocomplete} name="Multiple tags autocomplete" height="200px" inline={false}></Story>
</Canvas>
